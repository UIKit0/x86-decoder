
# Test ModRM variants without SIB byte.

# mod=0
movl %ebx, (%ecx)
  89 19
movl %ebx, VALUE32
  89 1d XX XX XX XX
# mod=1
movl %ebx, VALUE8(%ecx)
  89 59 XX
# mod=2
movl %ebx, VALUE32(%ecx)
  89 99 XX XX XX XX
# mod=3
movl %ebx, %ecx
  89 d9
  8b cb

# Test ModRM variants with SIB byte.

# mod=0
movl %ebx, (%ecx, %edx, 1)
  89 1c 11
# mod=1
movl %ebx, VALUE8(%ecx, %edx, 1)
  89 5c 11 XX
# mod=2
movl %ebx, VALUE32(%ecx, %edx, 1)
  89 9c 11 XX XX XX XX

# %ebp is treated as a special case in this position.
# %ebp is not allowed when mod=0.
# Instead you have to use the longer form.
movl %ebx, (%ebp, %ecx, 1)
movl %ebx, VALUE8(%ebp, %ecx, 1)
  89 5c 0d XX
movl %ebx, VALUE32(%ebp, %ecx, 1)
  89 9c 0d XX XX XX XX

# The reason for this is that it allows 'XX(%esp)' addressing, which
# is not allowed without a SIB byte unlike for other registers.
# aka. movl %ebx, (%esp, %eiz, 1)
movl %ebx, (%esp)
  89 1c 24
movl %ebx, VALUE8(%esp)
  89 5c 24 XX
movl %ebx, VALUE32(%esp)
  89 9c 24 XX XX XX XX

# There are various non-canonical forms of 'movl %reg, XXX(%esp)'
# with scales other than 1.
movl %ebx, (%esp, %eiz, 2)
  89 1c 64
movl %ebx, (%esp, %eiz, 4)
  89 1c a4
movl %ebx, VALUE8(%esp, %eiz, 2)
  89 5c 64 XX
movl %ebx, VALUE32(%esp, %eiz, 8)
  89 9c e4 XX XX XX XX

# Test other scales.
movl %ebx, (%ecx, %edx, 2)
  89 1c 51
movl %ebx, (%ecx, %edx, 4)
  89 1c 91
movl %ebx, (%ecx, %edx, 8)
  89 1c d1

# %esp is not allowed in this position.
movl %ebx, (%ecx, %esp, 1)
movl %ebx, (%ecx, %esp, 2)
movl %ebx, (%ecx, %esp, 4)
movl %ebx, (%ecx, %esp, 8)

# Instead, %eiz is used as a non-canonical form.
movl %ebx, (%ecx, %eiz, 1)
  89 1c 21
movl %ebx, (%ecx, %eiz, 2)
  89 1c 61
movl %ebx, (%ecx, %eiz, 4)
  89 1c a1
movl %ebx, (%ecx, %eiz, 8)
  89 1c e1


# Immediates.
movl $VALUE32, (%ebx)
  c7 03 XX XX XX XX
# 'mov' has a special short form when loading an immediate into a register.
movl $VALUE32, %ebx
  bb XX XX XX XX
  c7 c3 XX XX XX XX


# 'mov' has two special short forms for loading/storing %eax.
movl VALUE32, %eax
  8b 05 XX XX XX XX
  a1 XX XX XX XX
movl %eax, VALUE32
  89 05 XX XX XX XX
  a3 XX XX XX XX


# Test 16-bit operations.

movw %bx, %cx
  66 89 d9
  66 8b cb
movw %bx, (%ebx)
  66 89 1b
movw %bx, (%ebx, %ecx, 1)
  66 89 1c 0b
movw %bx, VALUE8(%ebx)
  66 89 5b XX
movw %bx, VALUE32(%ebx)
  66 89 9b XX XX XX XX
movw (%ebx), %bx
  66 8b 1b
movw $VALUE16, (%ebx)
  66 c7 03 XX XX
movw $VALUE16, %bx
  66 bb XX XX
  66 c7 c3 XX XX
movw VALUE32, %ax
  66 8b 05 XX XX XX XX
  66 a1 XX XX XX XX
movw %ax, VALUE32
  66 89 05 XX XX XX XX
  66 a3 XX XX XX XX


# Test 8-bit operations.

movb %bl, %ch
  88 dd
  8a eb
movb %bl, (%ebx)
  88 1b
movb %bl, (%ebx, %ecx, 1)
  88 1c 0b
movb %bl, VALUE8(%ebx)
  88 5b XX
movb %bl, VALUE32(%ebx)
  88 9b XX XX XX XX
movb (%ebx), %bl
  8a 1b
movb $VALUE8, (%ebx)
  c6 03 XX
movb $VALUE8, %bl
  b3 XX
  c6 c3 XX
movb VALUE32, %al
  8a 05 XX XX XX XX
  a0 XX XX XX XX
movb %al, VALUE32
  88 05 XX XX XX XX
  a2 XX XX XX XX


addl $VALUE32, %ebx
  81 c3 XX XX XX XX
addl $VALUE32, (%ebx)
  81 03 XX XX XX XX
addb $VALUE8, %bl
  80 c3 XX
addl %ebx, %ecx
  01 d9
  03 cb
addw %ax, %bx
  66 01 c3
  66 03 d8
addb %cl, %bl
  00 cb
  02 d9

# Extra opcodes for %eax/%ax/%al.
addl $VALUE32, %eax
  05 XX XX XX XX
  81 c0 XX XX XX XX
addw $VALUE16, %ax
  66 05 XX XX
  66 81 c0 XX XX
addb $VALUE8, %al
  04 XX
  80 c0 XX

# Extra opcodes for small immediates.
addl $VALUE8, (%eax)
  83 00 XX
addw $VALUE8, (%eax)
  66 83 00 XX


subl $VALUE32, %ebx
  81 eb XX XX XX XX
subl $VALUE32, (%ebx)
  81 2b XX XX XX XX
subb $VALUE8, %bl
  80 eb XX
subl %ebx, %ecx
  29 d9
  2b cb
subw %ax, %bx
  66 29 c3
  66 2b d8
subb %cl, %bl
  28 cb
  2a d9

# Extra opcodes for %eax/%ax/%al.
subl $VALUE32, %eax
  2d XX XX XX XX
  81 e8 XX XX XX XX
subw $VALUE16, %ax
  66 2d XX XX
  66 81 e8 XX XX
subb $VALUE8, %al
  2c XX
  80 e8 XX

# Extra opcodes for small immediates.
subl $VALUE8, (%eax)
  83 28 XX
subw $VALUE8, (%eax)
  66 83 28 XX
